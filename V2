#include <stdio.h>
#include <winsock2.h>
#include <stdlib.h>
#include <iostream>
#include <map>
#include <math.h>
#include <string>
#include<unistd.h>
#include <zlib.h>
#include <thread>
#pragma comment(lib, "Ws2_32.lib")
#define M_PI 3.14159265358979323846
using namespace std;
std::map<int,map<std::string, std::map<int, std::string>>> channels;
union d0
{int num :8 ;
    map <int,string> ch{{ 0,"altvoltage1"}, { 1,"voltage0"}, { 2,"voltage3"},{ 3,"altvoltage0"},{ 4,"voltage2"},{5,"tmp"},{6,"out"},{7,"voltage0"}};

};
struct comp
{
    short  i,Q ;
};
void com2mag(int len , short * A,comp * d)
{
  for(int i=0;i<len;i++)
  {
    A[i]=((d[i].i)) ;
  }
  return;
}
void sine(comp * A,int len,int N,int S,float th)
{
for(int i=0;i<len;i+=N){
    for(int I=0;I<N;I++)
{
  A[i+I].i=(short)(cos((2*3.141*I/N)+th)*32767)/S;

  A[i+I].Q=(short)(sin((2*3.141*I/N)+th)*32767)/S ;
   //printf("(0x%02X,0x%02X),  ",(int)(uint16_t) A[i+I].i,(int)(uint16_t) A[i+I].Q);
//if(th!=1)cout<<(sqrt(pow(A[i+I].Q,2)+pow(A[i+I].i,2))*cos(atan2(A[i+I].Q,A[i+I].i)))<<",   ";
//if(th!=1)cout<<A[i+I].i<<"  "<<A[i+I].Q<<"   ";
}//if(th!=1)exit(1);
}
    return;
}
void ran(comp * A,int len,int N)
{float th=((360/N)*3.141)/180;
for(int i=0;i<len;i+=4){
    for(int I=0;I<N;I++)
{
   A[i+I].i=(short)rand() ;
   A[i+I].Q=(short)rand() ;

}

}
    return;
}

void QPSk2(comp *Qpsk,unsigned char * data,int len ,int N)
{float ph[4]={-2.356,-0.785,2.356,0.785};
unsigned char a=0;
    for(int i=0,q=0;i<len;i+=N,q++)
   {
        if(q%4==0&&i!=0)
   {
    data ++;

   }
      a=*data&3;

   *data=*data>>2;

   sine(&Qpsk[i],N,N,1,ph[a]);


   }
 return;
}


void QPSk(comp *Qpsk,unsigned char * data,int len ,int N)
{comp I[len],Q[len];
 sine(I,len, N,2,0) ;
 sine(Q,len, N,2,(90*3.141)/180) ;

 char a,b;
   for(int i=0,q=0;i<len;i+=N,q++)
   {
        if(q%4==0&&i!=0)
   {
    data ++;

   }
      a=*data&1;
   *data=*data>>1;
   b=*data&1;
   *data=*data>>1;

   if(!a)a=-1;
   if(!b)b=-1;

       for(int ii=0;ii<N;ii++)
       {
        Qpsk[i+ii].i=(I[i+ii].i*a)+(Q[i+ii].i*b);
        Qpsk[i+ii].Q=(I[i+ii].Q*a)+(Q[i+ii].Q*b);
//cout<<(sqrt(pow(Qpsk[i+ii].Q,2)+pow(Qpsk[i+ii].i,2))*cos(atan2(Qpsk[i+ii].Q,Qpsk[i+ii].i)))<<",   ";

       }
   }
 return;
}

int che(char *A)
{
  if(A[0]<30) return 0 ;
  return 1;

}
double normalize_angle(double theta) {
    theta = fmod(theta + M_PI, 2 * M_PI);
    if (theta < 0) {
        theta += 2 * M_PI;
    }
    return theta - M_PI;
}

int S_comp(char *A, char *B, int len ,int N)
{char en[len];
unsigned char s=0,ch=0;
int comp =0,d=0,g=0,ra=0;
std::fill(en, en+len, 1);

   for(int i=0; i<=len ;i+=N)
   {int f=1;

   g=(N*128);//128 blocks *N
   bbb:
if(len-i<=(128*N))ch=1,g=len-i;// max len limit check

      if(en[i]==0){i+=N;// already compresed skip
      goto bbb;
      }
unsigned char cc=1;
    for(int c=N;c<g&&f==1;c+=N,cc++)//cc is block ID
    {//cout<<cc<<"   ";

        if (i + c + N > len) break;
       if(abs(A[i]-A[i+c])<=2&&en[i+c]==1)

            {//cout<<(int)A[i]<<"=="<<(int)A[i+c]<<endl;
                int t=1;
               // cout<<"1:"<<i<<endl;



       for(int h=1;h<N;h++)
       {//cout<<(int)A[i+h]<<"=="<<(int)A[i+c+h]<<endl;
           if(abs(A[i+h]-A[i+c+h])>2)
           {
               t=7;
               break;
           }
         //  if(i>1007&&cout<<(int)A[i+h]<<"=="<<(int)A[i+c+h]<<endl;
       }
       //cout<<endl;
         if(t<2)   {comp++;
                en[i+c]=0;
ra++;
s=1;
 asm("shl %1,%0" : "+r"(cc) : "cI"((unsigned char)1));
s|=(cc);

//cout<<endl<<(s>>1)<<endl;
            f=0;

         }
       }

    }

B[d]=s;
for(int I=0;I<N;I++){
    B[d+1+I]=A[i+I];//putting the block in the new array

     // asm("shr %1,%0" : "+r"(s) : "cI"((unsigned char)1));

//if(s&1)cout<<(int)A[i+I]<<"=="<<(int)A[i+I+(N*(s>>1))]<<"||"<<(s>>1)<<"++"<<(B[d]>>1)<<endl;
}
    d+=(N+1);




s=0;
ra=i;
   }cout<<endl<<ra<<"=="<<len<<endl;
//cout<<(float)(ra*N)/len;
d-=N+1;
return d;
}

int S_decomp(unsigned char *A,unsigned  char *B, int len ,int N)
{char en[len*2];
int ii=0,ra=0;
std::fill(en, en+(len*2), 1);

for(int i=0;i<len;i+=N+1,ii+=N)
{//cout<<i<<"  ";
    fff:
  if(en[ii]==0){

    ii+=N;
    goto fff;
  }
      for(int c=0;c<N;c++)
      {
       B[ii+c]=A[i+c+1]  ;
      }

      if((A[i]&1)==1)
      {unsigned char a=A[i];
      asm("shr %1,%0" : "+r"(a) : "cI"((unsigned char)1));
ra++;
en[ii+(a*N)]=0;
//cout<<(A[i]>>1)<<"   ";
         for(int c=0;c<N;c++)
      {
       B[ii+c+(a*N)]=A[i+c+1]  ;
      }

      }

}
cout<<endl<<ra<<endl;
return ii;
}
double add_angles(double a, double b) {
    return normalize_angle(a + b);
}


double subtract_angles(double a, double b) {
    return normalize_angle(a - b);
}

double an_difference(double theta1, double theta2) {
    double diff = fabs(theta1 - theta2);  // Absolute raw difference
    diff = fmod(diff, 2.0 * M_PI);       // Wrap to [0, 2π)
    if (diff > M_PI) {
        diff = 2.0 * M_PI - diff;        // Reflect to get smallest angle
    }
    return diff;  // Range: [0, π]
}
template <typename t> float demod(t *A ,int N)
{
   float I[N],Q[N];
   for(int i=0;i<N;i++)
   {I[i]=cos(M_PI*2*((float)i/N));
    Q[i]=sin(M_PI*2*((float)i/N));
   }
   float a=0,b=0;
   for(int i=0;i<N;i++)
   {
       a+=(float)I[i]*A[i];
       b+=(float)Q[i]*A[i];

   }
   return atan2(-b,a);
}


void short2byte(short *A, char* B,int len)
{
  float c=0;
  for(int i=0;i<len;i++)
  {
    c= ((( float)A[i]/(4096))*127) ;

   B[i]=(signed char)c;

   //cout<<(int)B[i]<<endl;
  }

  return;
}

float er(float a)
{float g[4]={0.785,-2.356,-0.785,2.356};
    float t=30;

    for(int i=0;i<2;i++)
    {
       if(t> an_difference(g[i],a)) t=an_difference(g[i],a);
    }
    return t;
}
int com2re(comp *A,short *B, int len)
{
//float I[8]={1,0.707,0,-0.707,-1,-0.707,0,0.707,},Q[8]={0,0.707,1,0.707,0,-0.707,-1,-0.707},t=0,z=5000;
 char B1[len]={0};

int g=0;
 for(int i=0,k=0;i<len;i++){
//cout<<A[i].i<<"="<<A[i].Q<<endl;
        if(sqrt(pow(A[i].i,2)+pow(A[i].Q,2))>0xff&&k==0)
 {k=1;

 }
       if(k) B[g]=(short)A[i].i,g++;
}

return g;


/*short2byte(&B[0],&B1[0],len);
 int m=0;

for(int i=0;i<8;i++)
{
t=0;

for(int ii=i;ii<(i+(8*8));ii+=8)
    {
t+=er(demod< char>(&B1[ii],8));
cout<<demod(&B[ii],8)*(180/M_PI)<<"   ";
  }
t/=8;
cout<<t<<endl<<endl;
if(z>t)z=t,m=i;
}//for(;m>8;m-=8);

cout<<">>>"<<m<<":"<<demod< char>(&B1[m],8)<<endl;



for(int i=m;i<m+8000;i+=8)
{//i-=(int)(er(demod(&B[i],8))/1.57)*4;
cout<<demod< char>(&B1[i],8)*(180/M_PI)<<"   ";
}


/*for(int i=0,k=0;i<len;i++){if(A[i].i>0xff)k=1;
    if(i%4==0&&k)cout<<atan2(A[i].Q,A[i].i)<<"   ";
 }*/

}
int com2reT(comp *A,short *B, int len)
{

int g=0;
 for(int i=0,k=0;i<len;i++)
    {
       B[g]=(short)A[i].i,g++;
}

return g;
}

int ana(char * B1,int l)
{float th=an_difference(demod(&B1[0],8),0.785);
    int m=0;
cout<<demod<char>(&B1[0],8)*(180/M_PI)<<endl;
float t=0,z=5000;
for(int i=0;i<1;i++)
{
t=0;

for(int ii=i;ii<(i+(8*8));ii+=8)
    {
t+=er(demod< char>(&B1[ii],8));
cout<<subtract_angles((demod(&B1[ii],8)),th)*(180/M_PI)<<"   ";
  }
t/=8;
cout<<t<<endl<<endl;
if(z>t)z=t,m=i;
}

cout<<">>>"<<m<<":"<<demod< char>(&B1[m],8)<<endl;
m=0;


for(int i=m;i<m+8000;i+=8)
{//i-=(int)(er(demod(&B[i],8))/1.57)*4;
cout<<subtract_angles((demod(&B1[i],8)),th)*(180/M_PI)<<"   ";
}

return 1;

}


class adalm
{public:
    map <int ,string>mp;
    map <int ,map<int,string>>t;
     map <int ,string>co{{0,"WRITE"},{1,"READ"},{2,"READBUF"},{3,"OPEN"},{3,"WRITEBUF"}};
    unsigned long long *d,con,re,wr;
  adalm() {   mp[0]="iio:device0",mp[1]="iio:device1",mp[2]="iio:device2",mp[3]="iio:device3";
  t[0][0]="OUTPUT", t[0][1]="OUTPUT", t[0][2]="DEBUG", t[0][3]="INPUT" , t[0][4]="INPUT", t[0][5]="INPUT", t[0][6]="OUTPUT", t[0][7]="INPUT", t[0][8]="OUTPUT", t[0][9]="OUTPUT";
   t[1][0]="INPUT", t[1][1]="INPUT", t[1][2]="INPUT", t[1][3]="INPUT", t[1][4]="INPUT", t[1][5]="INPUT", t[1][6]="INPUT", t[1][7]="INPUT", t[1][8]="INPUT", t[1][9]="" ;
  t[2][0]="", t[2][1]="DEBUG", t[2][2]="OUTPUT", t[2][3]="OUTPUT", t[2][4]="", t[2][5]="DEBUG", t[2][4]="OUTPUT", t[2][5]="OUTPUT",t[2][6]="OUTPUT";;
   t[3][2]="", t[3][1]="DEBUG",t[3][2]="INPUT", t[3][3]="INPUT";
  }
string av="";
intcontrol(char *ip)
{
 con = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);


    if ( con == INVALID_SOCKET) {
        printf("Socket creation failed: %d\n", WSAGetLastError());
        WSACleanup();
        return 1;
    }

    // Define server address
    struct sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(30431); // Server port
    serverAddr.sin_addr.s_addr = inet_addr("192.168.2.1"); // Server IP (localhost)

    // Connect to the server
    if (connect( con, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
        printf("Connection failed: %d\n", WSAGetLastError());
        closesocket( con);
        WSACleanup();
        return 1;
    }

    printf("Connected to server!\n");}




 intwrite(char *ip,int buff)
  {wr = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
string da="OPEN iio:device2 ";
da=da+std::to_string(buff);
da=da+" 00000003\r\n";
    if (wr == INVALID_SOCKET) {
        printf("Socket creation failed: %d\n", WSAGetLastError());

        return -1;
    }

    // Define server address
    struct sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(30431); // Server port
    serverAddr.sin_addr.s_addr = inet_addr(ip); // Server IP (localhost)

    // Connect to the server
    if (connect(wr, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
        printf("Connection failed: %d\n", WSAGetLastError());
        closesocket(wr);
        return -1;
    }

    if (send(wr, da.c_str(), da.length(), 0) == SOCKET_ERROR) {
        printf("Send failed: %d\n", WSAGetLastError());
        closesocket(wr);
        return -1;
    }
    char r[10];
 recv(wr,r , 4, 0);

  }


  intread(char *ip,int buff)
  {re = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
string da="OPEN iio:device3 ";
da=da+std::to_string(buff);
da=da+" 00000003\r\n";
    if (re == INVALID_SOCKET) {
        printf("Socket creation failed: %d\n", WSAGetLastError());

        return -1;
    }

    // Define server address
    struct sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(30431); // Server port
    serverAddr.sin_addr.s_addr = inet_addr(ip); // Server IP (localhost)

    // Connect to the server
    if (connect(re, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
        printf("Connection failed: %d\n", WSAGetLastError());
        closesocket(re);
        return -1;
    }

    if (send(re, da.c_str(), da.length(), 0) == SOCKET_ERROR) {
        printf("Send failed: %d\n", WSAGetLastError());
        closesocket(re);
        return -1;
    }
    char r[10];
 recv(re,r , 4, 0);

  }

 int writebuff(char *recvBuffer,int bufsize)
 {string da="WRITEBUF iio:device2 ";
 da=da+std::to_string(bufsize)+"\r\n";
      if (send(wr,da.c_str(), da.length(), 0) == SOCKET_ERROR) {
        printf("Send failed: %d\n", WSAGetLastError());
        return -1;
    }
    int g=0,e=0,m=0;

    recv(wr, recvBuffer,2, 0);

  do{
    g= send(wr, &recvBuffer[m], bufsize-m, 0);
    if(g>0)m+=g;
    e++;
    if(e>10000)return -1;
  }while(g<1||m<bufsize);

  return m;
 }

  int readbuff(char *recvBuffer,int bufsize)
 {char data[1460];
     string da="READBUF iio:device3 ";
 da=da+std::to_string(bufsize)+"\r\n";
      if (send(re,da.c_str(), da.length(), 0) == SOCKET_ERROR) {
        printf("Send failed: %d\n", WSAGetLastError());
        return -1;
    }
    int g=0,e=0,m=0;
    char G[12];
    recv(re, G, to_string(bufsize).length()+1, 0);
    recv(re, G, 9, 0);
  do{
    g= recv(re, &recvBuffer[m], bufsize, 0);

    if(g>0){m+=g;


    }
    if (g < 0) e++;

    if(e>100){ int wsa_error = WSAGetLastError();
    printf("WSA Error: %d\n", wsa_error);
            return -1;}
  }while(g<1||m<bufsize);

  return m;
 }


 void information()
 {
    cout<<"\nde0:\n0-altvoltage0\n1-altvoltage1\n2-debug\n3-out\n4-temp0\n5-voltage0_input\n6-voltage0_output\n7-voltage2_input\n8-voltage2_output\n9-voltage3\n"<<endl;
 cout<<"\nde1:\ntemp0\n0-voltage0\n1-voltage1\n2-voltage2\n3-voltage3\n4-voltage4\n5-voltage5\n6-voltage6\n7-voltage7\n8-voltage8\n9-zero"<<endl;
 cout<<"\nde2:\n0-altvoltage0\n1-altvoltage1\n2-altvoltage2\n3-altvoltage3\n4-buff\n5-debug\n6-voltage0\n7-voltage1"<<endl;
  cout<<"\nde3:\n0-buff\n1-debug\n2-voltage0\n3-voltage1"<<endl;
 }
int sam_av(int ud)
{
    char C[100];
    int d =av.find(' ');
    int b= av.find(' ',d+1);
   if(ud) atoi(  av.substr(1, d-1).c_str());

   else{
    return atoi(av.substr(b,(av.length()-b)-1).c_str());
   }

}
int fir(char *a,int bw,int sample)
{
  if(bw==20000000&&sample==1000000) strcpy(a,"RX 3 GAIN -6 DEC 1\nTX 3 GAIN 0 INT 4\n-15,-15\n-27,-27\n-23,-23\n-6,-6\n17,17\n33,33\n31,31\n9,9\n-23,-23\n-47,-47\n-45,-45\n-13,-13\n34,34\n69,69\n67,67\n21,21\n-49,-49\n-102,-102\n-99,-99\n-32,-32\n69,69\n146,146\n143,143\n48,48\n-96,-96\n-204,-204\n-200,-200\n-69,-69\n129,129\n278,278\n275,275\n97,97\n-170,-170\n-372,-372\n-371,-371\n-135,-135\n222,222\n494,494\n497,497\n187,187\n-288,-288\n-654,-654\n-665,-665\n-258,-258\n376,376\n875,875\n902,902\n363,363\n-500,-500\n-1201,-1201\n-1265,-1265\n-530,-530\n699,699\n1748,1748\n1906,1906\n845,845\n-1089,-1089\n-2922,-2922\n-3424,-3424\n-1697,-1697\n2326,2326\n7714,7714\n12821,12821\n15921,15921\n15921,15921\n12821,12821\n7714,7714\n2326,2326\n-1697,-1697\n-3424,-3424\n-2922,-2922\n-1089,-1089\n845,845\n1906,1906\n1748,1748\n699,699\n-530,-530\n-1265,-1265\n-1201,-1201\n-500,-500\n363,363\n902,902\n875,875\n376,376\n-258,-258\n-665,-665\n-654,-654\n-288,-288\n187,187\n497,497\n494,494\n222,222\n-135,-135\n-371,-371\n-372,-372\n-170,-170\n97,97\n275,275\n278,278\n129,129\n-69,-69\n-200,-200\n-204,-204\n-96,-96\n48,48\n143,143\n146,146\n69,69\n-32,-32\n-99,-99\n-102,-102\n-49,-49\n21,21\n67,67\n69,69\n34,34\n-13,-13\n-45,-45\n-47,-47\n-23,-23\n9,9\n31,31\n33,33\n17,17\n-6,-6\n-23,-23\n-27,-27\n-15,-15\n\n");
else if(bw==1000000&&sample==1000000)strcpy(a,"RX 3 GAIN -6 DEC 4\nTX 3 GAIN 0 INT 4\n-15,-15\n-27,-27\n-23,-23\n-6,-6\n17,17\n33,33\n31,31\n9,9\n-23,-23\n-47,-47\n-45,-45\n-13,-13\n34,34\n69,69\n67,67\n21,21\n-49,-49\n-102,-102\n-99,-99\n-32,-32\n69,69\n146,146\n143,143\n48,48\n-96,-96\n-204,-204\n-200,-200\n-69,-69\n129,129\n278,278\n275,275\n97,97\n-170,-170\n-372,-372\n-371,-371\n-135,-135\n222,222\n494,494\n497,497\n187,187\n-288,-288\n-654,-654\n-665,-665\n-258,-258\n376,376\n875,875\n902,902\n363,363\n-500,-500\n-1201,-1201\n-1265,-1265\n-530,-530\n699,699\n1748,1748\n1906,1906\n845,845\n-1089,-1089\n-2922,-2922\n-3424,-3424\n-1697,-1697\n2326,2326\n7714,7714\n12821,12821\n15921,15921\n15921,15921\n12821,12821\n7714,7714\n2326,2326\n-1697,-1697\n-3424,-3424\n-2922,-2922\n-1089,-1089\n845,845\n1906,1906\n1748,1748\n699,699\n-530,-530\n-1265,-1265\n-1201,-1201\n-500,-500\n363,363\n902,902\n875,875\n376,376\n-258,-258\n-665,-665\n-654,-654\n-288,-288\n187,187\n497,497\n494,494\n222,222\n-135,-135\n-371,-371\n-372,-372\n-170,-170\n97,97\n275,275\n278,278\n129,129\n-69,-69\n-200,-200\n-204,-204\n-96,-96\n48,48\n143,143\n146,146\n69,69\n-32,-32\n-99,-99\n-102,-102\n-49,-49\n21,21\n67,67\n69,69\n34,34\n-13,-13\n-45,-45\n-47,-47\n-23,-23\n9,9\n31,31\n33,33\n17,17\n-6,-6\n-23,-23\n-27,-27\n-15,-15\n\n");
    else return -1;

return 1;
}




  int WandR(char* data,char de,char ch,unsigned char art,bool w)
  {
string se;
if(w)se+="WRITE ";
else se+="READ ";

se=se+mp[de]+' ';
if((de==0&&ch==2))
{char fil[2048];
 strcpy(fil,"WRITE iio:device0 filter_fir_config 1142\r\n");
if(send(con,fil,strlen(fil),0)==-1)return -1;
if(send(con,data,strlen(data),0)==-1)return -1;
if(recv(con,fil,6,0)==-1)return -1;
return 1;
}
else if((de==1&&ch==9)||(de==2&&(ch==0||ch==4||ch==5))||(de==3&&(ch==1)))ch*=-1;
if(ch>-1)
{int i=0;

cout<<t[3][1]<<"<<<";

        for (const auto& channel : channels[de]) {



        if(i==ch){se=se+t[de][ch]+' ';

            string cha = channel.first.substr(0, channel.first.find('_'));

               if(t[de][ch]!="DEBUG") se+=cha +' '+channels[de][channel.first][art]+' ';
else se+=channels[de][channel.first][art]+' ';

        break;}
        i++;
        }




}
else
{
  ch*=-1 ;
  int i=0;

  for (const auto& channel : channels[de]) {

        if(i==ch){

               /* if(channel.first=="debug")se+="DEBUG ";
                else if(channel.first=="buff")return -1;*/
                    se+=" DEBUG ";
                se+=channels[de][channel.first][art]+' ';

        break;}
        i++;
}
}
if(w)se+=to_string(strlen(data)+1);
se+="\r\n";
cout<<se;
int er=0;
if(w){
while(send(con,se.c_str(),se.length(),0)==-1){
    er++;
    if(er>100){cout<<"connection lost"<<endl;
            return -1;
    }

}er=0;
///////////////////////////////////////////////////////////////////////////////////////////////
while(send(con,data,strlen(data)+1,0)==-1){
    er++;
    if(er>100){cout<<"connection lost"<<endl;
            return -1;
    }
}
char ch[5];

GGG:
er=recv(con,ch,10,0);
cout<<che(ch)<<endl;
if(!che(ch)&&er!=-1) goto GGG;

//ch[abs(er)]='\0';

if(er==-1)
{
    cout<<"command not complete";
    return -1;
}else if(stoi(ch)<0)
{
   return stoi(ch);

}
}else{


while(send(con,se.c_str(),se.length(),0)==-1){
    er++;
    if(er>100){cout<<"connection lost1"<<endl;
            return -1;
    }}

int U=0,e=0;
cout<<"dsd\n";
char da[8],da1[80]={0};
//do
//{
  U=recv(con,da,7,0)  ;
  e++;


//cout<<"||||||"<<da[0]<<"||||";



//}while(U==-1&&e<100);


if(U==-1||da[0]<30)return-1;
cout<<"tgtgrt";
e=0;
int m=0,l=atoi(da);
//struct timeval timeout = {5, 0};
//setsockopt(con, SOL_SOCKET, SO_RCVTIMEO, (const char*)&timeout, sizeof(timeout));
do{
U=recv(con,&da1[m],l-m+1,0);
if(U!=-1)m+=U;
e++;
cout<<l<<"="<<U<<"=="<<l-m;

}while(U==-1&&e<100);//(U==-1||m<l)&&e<1000
if(m<l-1)return -1;
cout<<"LLLL";

av=da1;
cout<<">>>"<<av<<"<<<"<<endl;
return 1;
}


  }




int opentransfer(unsigned long long *s,sockaddr_in *add,bool rec)
    {
        s[0]=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);


    if (s[0] == INVALID_SOCKET) {
        printf("Socket creation failed: %d\n", WSAGetLastError());
        WSACleanup();
        return 1;
    }

         if (connect(s[0], (struct sockaddr*)add, sizeof(add)) == SOCKET_ERROR) {
        printf("Connection failed: %d\n", WSAGetLastError());
        closesocket(s[0]);

        return 1;
    }
char da[100]="OPEN iio:device2 3276800000003\r\n";
if (rec)da[15]++;
    printf("Connected to server!\n");
    int er=0;
    while(send(s[0],da,strlen(da),0)==-1)
    {
     er++;
      if(er>100)

      {
          cout<<"connection lost"<<endl;
          return -1;
      }
    }
    return 1;
    }

int sendun(unsigned long long *a,int m )
{int er=0;
    switch(m)
        {
       case 0:
          while( send(*a,"ZPRINT\r\n",8,0)==-1)
          {
              if(er>100){cout<<"connection lost";
                return -1;
              }
          }
        break;
       case 1:
           while(send(*a,"PRINT\r\n",7,0)==-1)
           {
              if(er>100){cout<<"connection lost";
                return -1;
              }
           }
        break;
       case 2:

        break;
        }
}
int recany(unsigned long long *a,char * da )
{
    char len[10];
    int er=0;
    er=recv(*a,len,7,0);
    int r,r2;
    if(er==-1){
        cout<<"not received1";
        return -1;
    }
    if(len[0]<30||len[0]>39){cout<<"kopljilhoi";
            return -1;
    }
    while(er<stoi(len)){
    r=recv(*a,da,stoi(len),0);
    if(r!=-1)er+=r;
    if(r==-1){r++;
    if(r>100){
        er=-1;
        break;
    }
    break;}
    }

     if(er==-1){
        cout<<"not received2";
        return -1;
    }
return 1;
}
int timeout(unsigned long long *a,int t)
{string s="TIMEOUT ";
s+=to_string(t);
s+="\r\n";
   int er=0;
   while(send(*a,s.c_str(),s.length(),0)==-1){
    er++;
    if(er<100){
        cout<<"connection lost"<<endl;
        return -1;
    }
   }
   recv(*a,NULL,2,0);
   return 1;

}
};
void start(){

    // Channel altvoltage1
    channels[0]["altvoltage1"] = {
        {0, "external"},
        {1, "fastlock_load"},
        {2, "fastlock_recall"},
        {3, "fastlock_save"},
        {4, "fastlock_store"},
        {5, "frequency"},
        {6, "frequency_available"},
        {7, "powerdown"}
    };

    // Channel voltage0 (input)
    channels[0]["voltage0_input"] = {
        {0, "bb_dc_offset_tracking_en"},
        {1, "filter_fir_en"},
        {2, "gain_control_mode"},
        {3, "gain_control_mode_available"},
        {4, "hardwaregain"},
        {5, "hardwaregain_available"},
        {6, "quadrature_tracking_en"},
        {7, "rf_bandwidth"},
        {8, "rf_bandwidth_available"},
        {9, "rf_dc_offset_tracking_en"},
        {10, "rf_port_select"},
        {11, "rf_port_select_available"},
        {12, "rssi"},
        {13, "sampling_frequency"},
        {14, "sampling_frequency_available"}
    };

    // Channel voltage3
    channels[0]["voltage3"] = {
        {0, "filter_fir_en"},
        {1, "raw"},
        {2, "rf_bandwidth"},
        {3, "rf_bandwidth_available"},
        {4, "rf_port_select_available"},
        {5, "sampling_frequency"},
        {6, "sampling_frequency_available"},
        {7, "scale"}
    };

    // Channel altvoltage0
    channels[0]["altvoltage0"] = {
        {0, "external"},
        {1, "fastlock_load"},
        {2, "fastlock_recall"},
        {3, "fastlock_save"},
        {4, "fastlock_store"},
        {5, "frequency"},
        {6, "frequency_available"},
        {7, "powerdown"}
    };

    // Channel voltage2 (output)
    channels[0]["voltage2_output"] = {
        {0, "filter_fir_en"},
        {1, "raw"},
        {2, "rf_bandwidth"},
        {3, "rf_bandwidth_available"},
        {4, "rf_port_select_available"},
        {5, "sampling_frequency"},
        {6, "sampling_frequency_available"},
        {7, "scale"}
    };

    // Channel temp0
    channels[0]["temp0"] = {
        {0, "in_temp0_input"}
    };

    // Channel voltage0 (output)
    channels[0]["voltage0_output"] = {
        {0, "filter_fir_en"},
        {1, "hardwaregain"},
        {2, "hardwaregain_available"},
        {3, "rf_bandwidth"},
        {4, "rf_bandwidth_available"},
        {5, "rf_port_select"},
        {6, "rf_port_select_available"},
        {7, "rssi"},
        {8, "sampling_frequency"},
        {9, "sampling_frequency_available"}
    };

    // Channel voltage2 (input)
    channels[0]["voltage2_input"] = {
        {0, "bb_dc_offset_tracking_en"},
        {1, "filter_fir_en"},
        {2, "gain_control_mode_available"},
        {3, "offset"},
        {4, "quadrature_tracking_en"},
        {5, "raw"},
        {6, "rf_bandwidth"},
        {7, "rf_bandwidth_available"},
        {8, "rf_dc_offset_tracking_en"},
        {9, "irf_port_select_available"},
        {10, "sampling_frequency"},
        {11, "sampling_frequency_available"},
        {12, "scale"}
    };
channels[0]["out"] = {
        {0, "voltage_filter_fir_en"}
    };
try{
channels[0]["debug"] = {
    {0, "calib_mode"},
    {1, "calib_mode_available"},
    {2, "dcxo_tune_coarse"},
    {3, "dcxo_tune_coarse_available"},
    {4, "dcxo_tune_fine"},
    {5, "dcxo_tune_fine_available"},
    {6, "ensm_mode"},
    {7, "ensm_mode_available"},
    {8, "filter_fir_config"},
    {9, "gain_table_config"},
    {10, "multichip_sync"},
    {11, "rssi_gain_step_error"},
    {12, "rx_path_rates"},
    {13, "trx_rate_governor"},
    {14, "trx_rate_governor_available"},
    {15, "tx_path_rates"},
    {16, "xo_correction"},
    {17, "xo_correction_available"},
    {18, "digital_tune"},
    {19, "calibration_switch_control"},
    {20, "multichip_sync"},
    {21, "gaininfo_rx2"},
    {22, "gaininfo_rx1"},
    {23, "bist_timing_analysis"},
    {24, "gpo_set"},
    {25, "bist_tone"},
    {26, "bist_prbs"},
    {27, "loopback"},
    {28, "initialize"},
    {29, "adi,bb-clk-change-dig-tune-enable"},
    {30, "adi,axi-half-dac-rate-enable"},
    {31, "adi,txmon-2-lo-cm"},
    {32, "adi,txmon-1-lo-cm"},
    {33, "adi,txmon-2-front-end-gain"},
    {34, "adi,txmon-1-front-end-gain"},
    {35, "adi,txmon-duration"},
    {36, "adi,txmon-delay"},
    {37, "adi,txmon-one-shot-mode-enable"},
    {38, "adi,txmon-dc-tracking-enable"},
    {39, "adi,txmon-high-gain"},
    {40, "adi,txmon-low-gain"},
    {41, "adi,txmon-low-high-thresh"},
    {42, "adi,gpo3-tx-delay-us"},
    {43, "adi,gpo3-rx-delay-us"},
    {44, "adi,gpo2-tx-delay-us"},
    {45, "adi,gpo2-rx-delay-us"},
    {46, "adi,gpo1-tx-delay-us"},
    {47, "adi,gpo1-rx-delay-us"},
    {48, "adi,gpo0-tx-delay-us"},
    {49, "adi,gpo0-rx-delay-us"},
    {50, "adi,gpo3-slave-tx-enable"},
    {51, "adi,gpo3-slave-rx-enable"},
    {52, "adi,gpo2-slave-tx-enable"},
    {53, "adi,gpo2-slave-rx-enable"},
    {54, "adi,gpo1-slave-tx-enable"},
    {55, "adi,gpo1-slave-rx-enable"},
    {56, "adi,gpo0-slave-tx-enable"},
    {57, "adi,gpo0-slave-rx-enable"},
    {58, "adi,gpo3-inactive-state-high-enable"},
    {59, "adi,gpo2-inactive-state-high-enable"},
    {60, "adi,gpo1-inactive-state-high-enable"},
    {61, "adi,gpo0-inactive-state-high-enable"},
    {62, "adi,gpo-manual-mode-enable-mask"},
    {63, "adi,gpo-manual-mode-enable"},
    {64, "adi,aux-dac2-tx-delay-us"},
    {65, "adi,aux-dac2-rx-delay-us"},
    {66, "adi,aux-dac2-active-in-alert-enable"},
    {67, "adi,aux-dac2-active-in-tx-enable"},
    {68, "adi,aux-dac2-active-in-rx-enable"},
    {69, "adi,aux-dac2-default-value-mV"},
    {70, "adi,aux-dac1-tx-delay-us"},
    {71, "adi,aux-dac1-rx-delay-us"},
    {72, "adi,aux-dac1-active-in-alert-enable"},
    {73, "adi,aux-dac1-active-in-tx-enable"},
    {74, "adi,aux-dac1-active-in-rx-enable"},
    {75, "adi,aux-dac1-default-value-mV"},
    {76, "adi,aux-dac-manual-mode-enable"},
    {77, "adi,aux-adc-decimation"},
    {78, "adi,aux-adc-rate"},
    {79, "adi,temp-sense-decimation"},
    {80, "adi,temp-sense-periodic-measurement-enable"},
    {81, "adi,temp-sense-offset-signed"},
    {82, "adi,temp-sense-measurement-interval-ms"},
    {83, "adi,elna-gaintable-all-index-enable"},
    {84, "adi,elna-rx2-gpo1-control-enable"},
    {85, "adi,elna-rx1-gpo0-control-enable"},
    {86, "adi,elna-bypass-loss-mdB"},
    {87, "adi,elna-gain-mdB"},
    {88, "adi,elna-settling-delay-ns"},
    {89, "adi,ctrl-outs-enable-mask"},
    {90, "adi,ctrl-outs-index"},
    {91, "adi,rssi-duration"},
    {92, "adi,rssi-wait"},
    {93, "adi,rssi-delay"},
    {94, "adi,rssi-unit-is-rx-samples-enable"},
    {95, "adi,rssi-restart-mode"},
    {96, "adi,fagc-adc-large-overload-inc-steps"},
    {97, "adi,fagc-power-measurement-duration-in-state5"},
    {98, "adi,fagc-rst-gla-if-en-agc-pulled-high-mode"},
    {99, "adi,fagc-rst-gla-en-agc-pulled-high-enable"},
    {100, "adi,fagc-rst-gla-large-lmt-overload-enable"},
    {101, "adi,fagc-rst-gla-large-adc-overload-enable"},
    {102, "adi,fagc-energy-lost-stronger-sig-gain-lock-exit-cnt"},
    {103, "adi,fagc-rst-gla-engergy-lost-sig-thresh-below-ll"},
    {104, "adi,fagc-rst-gla-engergy-lost-goto-optim-gain-enable"},
    {105, "adi,fagc-rst-gla-engergy-lost-sig-thresh-exceeded-enable"},
    {106, "adi,fagc-rst-gla-stronger-sig-thresh-above-ll"},
    {107, "adi,fagc-optimized-gain-offset"},
    {108, "adi,fagc-rst-gla-stronger-sig-thresh-exceeded-enable"},
    {109, "adi,fagc-use-last-lock-level-for-set-gain-enable"},
    {110, "adi,fagc-gain-index-type-after-exit-rx-mode"},
    {111, "adi,fagc-gain-increase-after-gain-lock-enable"},
    {112, "adi,fagc-final-overrange-count"},
    {113, "adi,fagc-lmt-final-settling-steps"},
    {114, "adi,fagc-lpf-final-settling-steps"},
    {115, "adi,fagc-lock-level-gain-increase-upper-limit"},
    {116, "adi,fagc-lock-level-lmt-gain-increase-enable"},
    {117, "adi,fagc-lp-thresh-increment-steps"},
    {118, "adi,fagc-lp-thresh-increment-time"},
    {119, "adi,fagc-allow-agc-gain-increase-enable"},
    {120, "adi,fagc-state-wait-time-ns"},
    {121, "adi,fagc-dec-pow-measurement-duration"},
    {122, "adi,agc-immed-gain-change-if-large-lmt-overload-enable"},
    {123, "adi,agc-immed-gain-change-if-large-adc-overload-enable"},
    {124, "adi,agc-gain-update-interval-us"},
    {125, "adi,agc-sync-for-gain-counter-enable"},
    {126, "adi,agc-dig-gain-step-size"},
    {127, "adi,agc-dig-saturation-exceed-counter"},
    {128, "adi,agc-lmt-overload-large-inc-steps"},
    {129, "adi,agc-lmt-overload-small-exceed-counter"},
    {130, "adi,agc-lmt-overload-large-exceed-counter"},
    {131, "adi,agc-adc-lmt-small-overload-prevent-gain-inc-enable"},
    {132, "adi,agc-adc-large-overload-inc-steps"},
    {133, "adi,agc-adc-large-overload-exceed-counter"},
    {134, "adi,agc-adc-small-overload-exceed-counter"},
    {135, "adi,agc-outer-thresh-low-inc-steps"},
    {136, "adi,agc-outer-thresh-low"},
    {137, "adi,agc-inner-thresh-low-inc-steps"},
    {138, "adi,agc-inner-thresh-low"},
    {139, "adi,agc-inner-thresh-high-dec-steps"},
    {140, "adi,agc-inner-thresh-high"},
    {141, "adi,agc-outer-thresh-high-dec-steps"},
    {142, "adi,agc-outer-thresh-high"},
    {143, "adi,agc-attack-delay-extra-margin-us"},
    {144, "adi,mgc-split-table-ctrl-inp-gain-mode"},
    {145, "adi,mgc-dec-gain-step"},
    {146, "adi,mgc-inc-gain-step"},
    {147, "adi,mgc-rx2-ctrl-inp-enable"},
    {148, "adi,mgc-rx1-ctrl-inp-enable"},
    {149, "adi,gc-use-rx-fir-out-for-dec-pwr-meas-enable"},
    {150, "adi,gc-max-dig-gain"},
    {151, "adi,gc-dig-gain-enable"},
    {152, "adi,gc-low-power-thresh"},
    {153, "adi,gc-dec-pow-measurement-duration"},
    {154, "adi,gc-lmt-overload-low-thresh"},
    {155, "adi,gc-lmt-overload-high-thresh"},
    {156, "adi,gc-adc-large-overload-thresh"},
    {157, "adi,gc-adc-small-overload-thresh"},
    {158, "adi,gc-adc-ovr-sample-size"},
    {159, "adi,gc-rx2-mode"},
    {160, "adi,gc-rx1-mode"},
    {161, "adi,update-tx-gain-in-alert-enable"},
    {162, "adi,tx-attenuation-mdB"},
    {163, "adi,rf-tx-bandwidth-hz"},
    {164, "adi,rf-rx-bandwidth-hz"},
    {165, "adi,qec-tracking-slow-mode-enable"},
    {166, "adi,dc-offset-count-low-range"},
    {167, "adi,dc-offset-count-high-range"},
    {168, "adi,dc-offset-attenuation-low-range"},
    {169, "adi,dc-offset-attenuation-high-range"},
    {170, "adi,dc-offset-tracking-update-event-mask"},
    {171, "adi,clk-output-mode-select"},
    {172, "adi,external-rx-lo-enable"},
    {173, "adi,external-tx-lo-enable"},
    {174, "adi,xo-disable-use-ext-refclk-enable"},
    {175, "adi,tx-lo-powerdown-managed-enable"},
    {176, "adi,trx-synthesizer-target-fref-overwrite-hz"},
    {177, "adi,rx1-rx2-phase-inversion-enable"},
    {178, "adi,tx-rf-port-input-select-lock-enable"},
    {179, "adi,rx-rf-port-input-select-lock-enable"},
    {180, "adi,tx-rf-port-input-select"},
    {181, "adi,rx-rf-port-input-select"},
    {182, "adi,split-gain-table-mode-enable"},
    {183, "adi,1rx-1tx-mode-use-tx-num"},
    {184, "adi,1rx-1tx-mode-use-rx-num"},
    {185, "adi,2rx-2tx-mode-enable"},
    {186, "adi,digital-interface-tune-fir-disable"},
    {187, "adi,digital-interface-tune-skip-mode"},
    {188, "adi,tx-fastlock-pincontrol-enable"},
    {189, "adi,rx-fastlock-pincontrol-enable"},
    {190, "adi,rx-fastlock-delay-ns"},
    {191, "adi,tx-fastlock-delay-ns"},
    {192, "adi,tdd-skip-vco-cal-enable"},
    {193, "adi,tdd-use-dual-synth-mode-enable"},
    {194, "adi,debug-mode-enable"},
    {195, "adi,ensm-enable-txnrx-control-enable"},
    {196, "adi,ensm-enable-pin-pulse-mode-enable"},
    {197, "adi,frequency-division-duplex-independent-mode-enable"},
    {198, "adi,frequency-division-duplex-mode-enable"},
    {199, "direct_reg_access"}
};}
catch(const std::bad_alloc& e) {
        std::cerr << "Memory allocation failed: " << e.what() << std::endl;
        return ;
    }
//cout<<channels[0]["debug"].max_size();

    // Populate the map with the given data
    channels[1]["voltage5"] = {
        {0, "raw"},
        {1, "scale"}
    };
    channels[1]["voltage0"] = {
        {0, "raw"},
        {1, "scale"}
    };
    channels[1]["voltage4"] = {
        {0, "raw"},
        {1, "scale"}
    };
    channels[1]["temp0"] = {
        {0, "offset"},
        {1, "raw"},
        {2, "scale"}
    };
    channels[1]["voltage7"] = {
        {0, "raw"},
        {1, "scale"}
    };
    channels[1]["voltage1"] = {
        {0, "raw"},
        {1, "scale"}
    };
    channels[1]["voltage2"] = {
        {0, "raw"},
        {1, "scale"}
    };
    channels[1]["voltage3"] = {
        {0, "raw"},
        {1, "scale"}
    };
    channels[1]["voltage8"] = {
        {0, "raw"},
        {1, "scale"}
    };
    channels[1]["voltage6"] = {
        {0, "raw"},
        {1, "scale"}
    };
 channels[1]["zero"] = {{0,"sampling_frequency"}};

    channels[2]["voltage0"] = {
        {0, "calibphase"},
        {1, "calibscale"},
        {2, "sampling_frequency"},
        {3, "sampling_frequency_available"}
    };
    channels[2]["voltage1"] = {
        {0, "calibphase"},
        {1, "calibscale"},
        {2, "sampling_frequency"},
        {3, "sampling_frequency_available"}
    };
    channels[2]["altvoltage3"] = {
        {0, "frequency"},
        {1, "phase"},
        {2, "raw"},
        {3, "frequency"},
        {4, "scale"}
    };
    channels[2]["altvoltage1"] = {
        {0, "frequency"},
        {1, "phase"},
        {2, "raw"},
        {3, "sampling_frequency"},
        {4, "scale"}
    };
    channels[2]["altvoltage0"] = {
        {0, "frequency"},
        {1, "phase"},
        {2, "raw"},
        {3, "frequency"},
        {4, "scale"}
    };
    channels[2]["altvoltage2"] = {
        {0, "frequency"},
        {1, "phase"},
        {2, "raw"},
        {3, "frequency"},
        {4, "scale"}
    };
channels[2]["BUFFER"] = {
   {0,"data_available" },
   {1,"length_align_bytes" }
   };
  channels[2]["DEBUG"]=
   {
    {0,"watermark" },
    {1,"direct_reg_access" }
};

    channels[3]["voltage0"] = {
        {0, "calibbias"},
        {1, "calibphase"},
        {2, "calibscale"},
        {3, "samples_pps"},
        {4, "sampling_frequency"},
        {5, "sampling_frequency_available"}
    };
    channels[3]["voltage1"] = {
        {0, "calibbias"},
        {1, "calibphase"},
        {2, "calibscale"},
        {3, "samples_pps"},
        {4, "sampling_frequency"},
        {5, "sampling_frequency_available"}
    };

    // Populate the map for buffer attributes under the "buff" channel
    channels[3]["BUFFER"] = {
        {0, "data_available"},
        {1, "length_align_bytes"},
        {2, "watermark"}
    };

    // Populate the map for debug attributes under the "debug" channel
    channels[3]["DEBUG"] = {
        {0, "pseudorandom_err_check"},
        {1, "direct_reg_access"}
    };

/*for(const auto s :channels[0]["debug"])

cout<<s.first<<'-'<<s.second<<endl;
}*/}
int main() {

adalm A;
    start();
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        printf("WSAStartup failed.\n");
        return 1;
    }
A.intcontrol("192.168.2.1");


    char dd[100000];



    const char* sendData = "ZPRINT\r\n";
    if (send(A.con, sendData, strlen(sendData), 0) == SOCKET_ERROR) {
        printf("Send failed: %d\n", WSAGetLastError());
        closesocket(A.con);
        WSACleanup();
        return 1;
    }

    printf("Data sent: %s\n", sendData);



   char *recvBuffer = new char[128000];
    char trash[1000];
    comp *z=( comp*)recvBuffer;

    int bytesReceived = recv(A.con, trash, sizeof(trash), 0);
    if (bytesReceived > 0) {
        trash[bytesReceived] = '\0'; ////////////
        printf("Received from server: %s\n", trash);
    } else if (bytesReceived == 0) {
        printf("Connection closed by server.\n");
    } else {
        printf("Receive failed: %d\n", WSAGetLastError());
    }

    if (send(A.con, "TIMEOUT 2500\r\n", 14, 0) == SOCKET_ERROR) {
        printf("Send failed: %d\n", WSAGetLastError());
        closesocket(A.con);
        WSACleanup();
        return 1;
    }
    recv(A.con, trash, sizeof(trash), 0);

char fil[2000];



A.WandR("2400000000",0,1,5,1);
A.WandR("2400000000",0,0,5,1);
A.WandR("100000",0,9,2,1);
A.WandR("100000",0,5,7,1);


while(A.WandR("1000000",2,6,3,0)==-1);
while(A.WandR("1000000",0,6,9,0)==-1);//read range
A.fir(fil ,1000000,1000000);

char str[20];
snprintf(str, sizeof(str), "%d", A.sam_av(1));

//cout<<A.av.substr(1, A.av.find(' '));
A.WandR("0",0,3,0,1);
A.WandR(str,0,6,8,1);

A.WandR(fil,0,2,8,1);//write filter

//A.WandR(str,0,6,8,1);

A.WandR("1",0,3,0,1);//en_filter

A.WandR("1000000",0,6,8,1);
//A.WandR((char *)(A.av.substr(1, A.av.find(' ')-1)+"\0\n").c_str(),0,6,8,1);



A.WandR("1000000",3,2,4,1);
getchar();
while(A.WandR("1000000",2,6,2,0)==-1);
while(A.WandR("1000000",2,6,3,0)==-1);
A.WandR("manual",0,5,2,1);
A.WandR("40",0,5,4,1);
A.WandR("1",0,5,6,1);
A.WandR("1",0,5,0,1);
//A.WandR("1",0,5,0,1);
getchar();

A.intwrite("192.168.2.1",32000);





//A.WandR("3000000000",3,0,0,0);
comp f[32000];
unsigned char te[8001];

for(int i=0;i<10;i++){
         te[i]=0x63;

}
for(int i=10;i<8001;i++){
         te[i]=rand();//0x00;

}
    //sine(f,32000,4,1,45*3.141/180.0);
   QPSk2(&f[0],te,32000,8);
  // f[0].i=0x7f,f[0].Q=0x7f;
   char  *buf=(char *)f;
A.intread("192.168.2.1",32000);
A.WandR("0x80000088 0x6",3,1,1,1);
A.WandR("2147483784",3,1,1,1);
   /*

   int I=0,Q=0;
   char tt[32000];
short tt2[32000];

com2re((short *)f,tt2,32000);
short2byte(tt2,tt,32000);
   for(int i=4 ;i<8;i++)
{I+=(cos((2*3.141*i/4))*tt[i]);
Q+=(-sin((2*3.141*i/4))*tt[i]);
    printf("%x   %x   ",tt[i],tt[i]);
}

cout<<atan2(Q,I)*(180/3.141)<<endl;
getchar();*/
//cout<<A.writebuff(recvBuffer,32000*4)<<endl;

//A.WandR("2400000000",0,1,5,1);
//A.WandR("20000000",2,6,2,1);


comp f1[32000];
char * buf2=(char *)f1;
int u=0,st=0;

A.WandR("",3,0,0,0);
A.WandR("",3,0,0,0);


st+=A.readbuff(buf2,32000*4);st+=A.readbuff(buf2,32000*4);st+=A.readbuff(buf2,32000*4);st+=A.readbuff(buf2,32000*4);



while(u<1){

   // thread F(&adalm::writebuff,&A,buf,32000*4);
   // usleep(500);
   //

   A.writebuff(buf,32000*4);

//thread F1(&adalm::readbuff,&A,(char*)f,32000*4);
//cout<<"dd";
//A.readbuff(buf,32000*4);
//cout<<"wdw";
  //F1.join();
 // thread F2(&adalm::readbuff,&A,(char*)f,32000*4);

cout<<A.readbuff(buf2,32000*4);

//cout<<A.readbuff(buf2,32000*4);
//A.writebuff(buf,32000*4);
//A.readbuff(buf2,32000*4);
 // F2.join();
//F.join();
//

       // A.readbuff(buf,32000*4);
u++;
       // usleep(30);
//A.WandR("3000000000",2,0,0,0);

}
int k=0;
short hh[32000];
//for(int i=0;i<16000;i++)printf("(0x%02X,0x%02X),  ",(int)(uint16_t) f1[i].i,(int)(uint16_t) f1[i].Q);
//exit(1);
//

int su=com2re(f1,hh,32000);
cout<<A.readbuff(buf2,32000*4);
com2reT(f1,&hh[su],32000-su);
//for(int i=0;i<32000;i++)cout<<i<<":"<<(short*)hh[i]<<"  ";
//cout<<endl<<32000-su;

//
//cout<<(32000*4)-su;
//exit(1);
su=32000;
char ne[su],ll;
short2byte(&hh[0],&ne[0],su);
su=(su-(su%8));
cout<<"comp"<<su<<endl;
char com[su],com2[su];
int kj=S_comp(&ne[0],com, su ,8);
cout<<"comp"<<kj<<endl;
for(int i=32000-10;i<32000;i++)cout<<i<<":"<<(short)ne[i]<<"  ";

kj=S_decomp((unsigned char *)&com[0], (unsigned char *)com2, kj-1 ,8);
cout<<endl;
for(int i=kj-10;i<kj;i++)cout<<i<<":"<<(short)com2[i]<<"  ";
cout<<"comp"<<kj<<endl;

for(int i=10000;i<kj;i++){
      //  if(i%8==0)cout<<endl<<i<<endl;
    // cout<<endl<<i<<":"<<((int)com2[i])<<"  "<<(int)ne[i];

}
//cout<<kj<<endl;
//for(int i=0;i+=5;i<kj)cout<<(int)com[i]<<"  ";
//exit(1);
//for(int i=0;i<su;i++)cout<<(int)ne[i]<<"   ";
ana(com2,su);

cin>>ll;
if(ll=='a')
{
    for(int i=0;i<su;i++)
    {
        printf("0x%02X , ",(int)(uint16_t) hh[i]);
    }
}
exit(1);
//for(int i=0;i<32000*4;i++2)printf("%x%x    ",buf2[i],buf2[i+1]);
//exit(1);
for(int i=0 ;i<32000;i++)
{if(sqrt(pow(f1[i].i,2)+pow(f1[i].Q,2))>0xff&&k==0)k=1;
  if(1)  printf("%x   %x   ",f1[i].i,f1[i].Q);
}

//A.WandR("3000000000",0,0,5,1);
//A.WandR("1000000",3,2,4,1);
//A.WandR("k",0,2,8,1);
//A.WandR("1",0,3,0,1);
//
//A.WandR(dd,0,0,8,0);


    closesocket(A.con);
    WSACleanup();

    return 0;
}
